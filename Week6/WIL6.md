# WIL6

## **1. 추상클래스와 인터페이스**

지난 글에서 추상화에 대한 이야기를 다뤘다. 이 글에선 자바가 추상화를 통해 객체지향을 어떻게 활용하고 있는지에 대해 다뤄보겠다.

자바에선 객체지향을 적극적으로 활용하기 위해 추상화를 통해 여러 객체를 만들고 연관관계가 있는 객체들의 공통성을 뽑아 super class로 만들기도하고 관련된 하위 sub class를 추가하기도 하는 '상속'관계를 적극 활용하고 있다. Super class에서 메소드를 정의하고 이를 오버라이딩을 통한 다형성을 적극 활용한다.

두가지 방법이 존재하는데 '추상클래스'와 '인터페이스'를 활용한 방법이 존재한다.

### **추상클래스**

추상클래스를 활용하기 위해선 extends로 표현한다.말그대로 상위 클래스인 SupClass, 추상 클래스에 정의된 내용을 '확장'하는 것이다. 오버라이딩을 통해 SupClass에서 정의한 내용을 재정의 하는데 **핵심은 SupClass에서도 메소드 정의가 가능**하다는 것이다.

따라서, SubClass는 상속받은 모든 메소드를 재정의할 필요가 없다. 또한 자바에선 abstract class를 여러개 상속받을 수 없다. 오직 하나의 부모 클래스에서만 상속을 받을 수 있다.

### **인터페이스**

인터페이스를 활용하기 위해선 implements로 표현한다.

```java
public class A implements SupCl{
	...
}
```

상위 클래스인 SupCl에서 정의한 함수들을 클래스 A에서 구현하는 것이다. 즉, 인터페이스인 SupCl에는 세부 코드가 구현되어있지 않다. 따라서, SubClass인 A는 인터페이스에서 정의한 **모든 메소드를 다 구현**해야한다. 또한 여러개의 인터페이스로부터 상속을 받아 구현할 수 있다. SupCl와 SupCl2에게도 상속을 받을 수 있다는 이야기이다.

또한, 인터페이스는 메소드가 구현되어 있지 않기 때문에 단독으로 사용할 수 없다.

둘의 차이를 생각해보면 활용도는 명확히 다르다. 부모 객체의 특정 메소드가 자식 개체에 오버라이딩되지 않고 부모 객체를 단독으로도 활용할 수 있어야한다면 추상클래스를 사용하는 것이 옳다. 그러나, 상위 클래스를 단독으로 활용할 일이 없고 상위 여러 클래스의 특정 개념을 구현하고자 한다면 인터페이스를 사용하는 것이 옳다.

## **2. static과 final 그리고 불변 객체**

### **static**

static의 의미를 생각해보자. static 정적인, 즉, 정적 변수를 의미한다. 클래스가 생성될때 static 메모리에 자리를 잡으며 클래스의 생성 여부와 상관없이 모든 인스턴스들이 공유하는 내용이다. 따라서 전역변수처럼 클래스의 모든 인스턴스가 값을 변경하고 활용할 수 있다.

### **final**

final은 '최종'의 의미를 띈다. 즉, 변수가 한 번 정의되면 다시는 바꿀 수 없는 것을 의미한다. C++로 생각하면 상수, const와 유사하다.

final 변수를 정의하는 방법은 두 가지가 존재하는데 첫째는 선언과 동시에 초기화를 해주는 것이고 둘째는 클래스를 생성할때 생성자에 해당 변수의 값을 넣어주는 두 가지 방식이 존재한다.

### **불변 객체**

위의 final과 관련해 ﻿불변 객체에 대해 생각해보자. 우선 생성이 되고, 정의가 된 후엔 다시 바뀌지 않는 객체를 불변객체라고 한다. 객체지향 프로그래밍에선 이를 생성 후에 변수등의 상태가 변하지 않는 객체를 불변 객체라고 이야기한다.

그렇다면 불변 객체는 어떻게 정의할 수 있을까?

두 가지 조건을 만족해야한다.

- 생성시에 정의가 되어야하고
- 정의된 후엔 외부에서 수정이 불가능해야한다.

두 조건을 만족하기 위해 앞서 배운 final 변수를 적극 활용할 것이다.

학생 클래스를 만들고 이름과 학번이라는 변수(상태)를 갖는다고 정의하자. 한 번 클래스넷에 등록되면 학번과 이름은 변하면 안된다.

```java
public class Student{
    private final String name;
    private final int id;

    public Student(String name, int id){
    	this.name = name;
        this.id = id;
    }
}
```

이렇게 final 변수를 활용하고 생성자를 통해 생성한다면 외부에서 객체를 수정할 수 없고 생성시에 정의가 되는 불변 객체 가 생성될 것이다.