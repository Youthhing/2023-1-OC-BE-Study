# WIL4

# **1. 순차 지향 프로그래밍과 절차 지향 프로그래밍의 특징과 차이**

### **순차 지향 프로그래밍**

순차 = sequential이다. 즉, 프로그램이 코드의 순서에 맞춰서 흐름대로 진행되게 프로그래밍을 하는 것을 의미한다.

### **절차 지향 프로그래밍**

절차 = procedual이다. Procedual의 개념은 조금 다르긴한데 여기서는 함수라고만 이해하자. 이때 반복되거나 재사용될 가능성이 있는 코드에 대해서 미리 procedual를 만들어 놓고 필요할때마다 이를 활용하게 프로그래밍하는 것을 의미한다.

**차이점?**

한 기능을 반복해서 실행한다고 생각해보자. 여기서는 a와b를 입력받고 이를 출력하는 기능을 구현한다고 생각하자.

간단한 CPP code를 보겠다.

```cpp
int main(void){
//a+b를 입력받고 더한 값을 sum으로 출력하는 코드

//순차int a = 0;
    int b= 0;
    cin>>a>>b;
    int sum = a+b;
    cout<<a+b<<"\n";
//goto문으로 위로 다시..!

//절차sum();
    return 0;
}
//절차void sum(){
	int a,b;
    cin>>a>>b;
    int sum = a+b;
    cout<<sum<<"\n";
}
```

이때 순차 지향 프로그래밍은 주로 goto문을 활용해 특정 시점으로 다시 돌아간다.

하지만 절차지향 프로그래밍에선 관련 Procedual( 함수와 유사 )를 만들어 놓고 이를 활용해 구현을 한다.

# **2. JVM의 역할과 가비지 컬렉션이란?**

**JVM이란?**

java virtual machine의 약자로 자바를 실행하기 위한 가상 머신을 의미한다. 기존 다른 언어같은 경우에는 프로그램 실행 환경, 가령 OS마다 그에 맞는 적절한 컴파일러를 설치해줘야했다. 그러나 JVM은 Java와 OS사이의 **중개자 역할**을 수행하여 OS에 구애 받지 않고 자바를 실행할 수 있게 함으로써 이 문제를 해결한다.

**가비지 컬렉션**

프로그래밍 코드를 짤때를 생각해보자. 특정 변수나 인스턴스를 사용하기 위해 선언하면 이들은 적절한 메모리를 할당 받는다. 이러한 인스턴스를 사용하고 더이상 사용하지 않게되면 이는 메모리상에서 의미 없는 Garbage가 되는데 이는 메모리 누수를 야기한다. C언어의 경우엔 이를 해결하기 위해 개발자가 직접 메모리를 해제할 수 있게 하나 자바엔 이러한 기능이 없다.

대신 가비지 컬렉터(Garbage collector)가 주기적으로 메모리를 검사하고 사용하지 않는 메모리를 관리해준다. 따라서, 개발자는 메모리를 신경쓰기보단 개발에만 집중할 수 있다는 장점이 존재한다.

그러나, 자동으로 관리해준다는 측면에 있어서 반대로, 개발자는 메모리가 언제 해제되는지 알 수 없고 이 GC가 실행되는 동안 다른 동작을 멈추기 때문에 소프트웨어가 멈추는 오버헤드가 발생한다는 단점 또한 존재한다.

# **3. 메소드, 힙, 스택 영역에 각각 어떤게 존재하는지?**

자바의 메모리 영역은 크게 3가지로 나눌 수 있다.

1. 메소드 영역

2. Heap 영역

3. Stack 영역

이렇게 구분할 수 있고 3가지 영역에 무엇이 존재하는지 설명해보겠다.

### **메소드 영역**

이 영역은 스태틱 영역, 클래스 영역이라고도 불린다.

JVM을 실행하면, 우선 java.lang이라는 패키지를 해당 영역에 가져다 놓아 자바 기본 메서드를 사용할 수 있게 해준다.

또한 해당 파일에 클래스를 스캔하여 클래스들을 이 영역에 로딩하고, Static 영역이라고도 불리는만큼 전역변수인 static 변수들을 해당 영역에 적재한다.

### **스택 영역 : 메서드들의 놀이터**

우선 자바가 실행되면서 메소드나 생성자가 실행되면 해당 스택프레임이 해당 영역에 적재된다. 이어서 해당 메소드에 필요한 지역변수, 인자에 대한 값들을 해당 스택프레임 영역에 적재한다. 또한 참고하는 Heap 영역의 값들에 대한 참조 또한 이곳에 적재된다.

### **힙 영역 : 객체들의 놀이터**

자바에서 실행되는 모든 인스턴스들을 이곳에 적재한다. 실행되는 객체들, new를 통해 메모리를 할당받은 존재들이 이곳에 저장된다.

# **4. 클래스는 붕어빵 틀이고 객체는 붕어빵이다 에 대해 논하라.**

이에 대해 클래스와 객체에 대한 차이부터 이야기를 해보겠다.

**클래스** : 객체의 집합을 '정의'한 것. 객체의 Attributes, operation,links,,를 정의한 것을 의미함.

**객체** : State/behavior를 가지고 클래스가 인스턴스화된 것을 의미함. 단순 정의가 아닌 실체화된 어떤 객체를 의미함

따라서, 클래스는 붕어빵 틀이고 객체는 붕어빵이다. 라는 말에 대해 객체는 우선, 붕어빵이 맞다고 생각한다. 정해진 틀에 의해서 상태와 기타 특성을 가진 실제 존재이니 말이다.

그러나, 클래스가 붕어빵 틀이라는데에는 조금 이견이 있다. 붕어빵을 만들기 위해 붕어빵을 정의한 것을 의미해야한다.

그전에 붕어빵의 속성에 대해 논하자면, 모양, 반죽, 재료등이 있다. 이 속성들중 모양은 붕어빵 틀이 정의할 수 있지만, 반죽과 재료는 실제 만들때 정해진다. 따라서, 붕어빵 틀이 붕어빵을 정의한다는 것은 옳지 않다고 생각한다.